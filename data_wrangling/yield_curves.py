# -*- coding: utf-8 -*-
"""
Library to download yield curves from treasury.gov and prepare the data.

The procedure consists of:
    - Download yield curves U.S. Treasuries from 2000 to 2023 for all
      maturities from 0 to 30 years.
    - Interpolate each curve using cubic splines.
    - Save the original downloaded curves and points generated by
      interpolation throughout the interval.    

Created on Mon Apr 22 20:19:16 2024

@author: pcmen
"""

import numpy as np
import pandas as pd
from scipy.interpolate import CubicSpline
import os
from utils.utils import load_config
import zipfile
from io import BytesIO
import sys

def get_yield_curve(year):
    """Downloads the yield curve for a given year from treasury.gov
    
    Returns a dataframe with the yield curves for all available maturities.
    Rows are sorted by date and no row is completely empty."""
    
    url_base = f"https://home.treasury.gov/resource-center/data-chart-center/interest-rates/daily-treasury-rates.csv/{year}/all"
    full_url = f"{url_base}?field_tdr_date_value={year}&type=daily_treasury_yield_curve&page&_format=csv"
    df = pd.read_csv(full_url)
    df.set_index("Date", inplace=True)
    df.index = pd.to_datetime(df.index, format='%m/%d/%Y')
    df.dropna(how="all", inplace=True)
    return df

def get_yields(start_year, end_year):
    """Returns yield curve data from years start_year to end_year (inclusive).
    Yields are sorted according to maturity."""
    
    years = [i for i in range(start_year, end_year + 1)]
    yields = pd.concat(get_yield_curve(year) for year in years)
    yields.sort_index(inplace=True)
    return yields[sorted(yields.columns, key=lambda x:(int(x[:-3])/12 if x[-2:] == 'Mo' else int(x[:-3])))]

def main():
    """Gets yield curves from 2010 to 2023 from treasury.gov, saves the data
    into file 'Yield curves.csv', interpolates the curve using splines,
    and saves the resulting dataframe into file 'interpolated_yield_curves.csv'."""
    print('Getting yields...')

    config = load_config()
    start_date = config.get('MetaData', 'raw_start_date')
    end_date = config.get('MetaData', 'end_date')

    start_year = int(start_date[:4])
    end_year = int(end_date[:4])

    yield_curves = get_yields(start_year, end_year)
    yield_curves.to_csv('../data/yield_curves.csv')
    
    print('Interpolating yields...')
    # sample every 0.1 years
    x_values = np.linspace(0, 30, 301)
    
    interpolated_yield_curves = pd.DataFrame(
        index=yield_curves.index,
        columns=x_values)
    
    for date, curve in yield_curves.iterrows():
        points = [(i, row_value) for i, row_value in curve.items() if not np.isnan(row_value)]
        x_points = [(int(i[:-3])/12 if i[-2:] == 'Mo' else int(i[:-3])) for i, j in points]
        y_points = [i[1] for i in points]
        f = CubicSpline(x_points, y_points) 
        
        interpolated_yield_curves.loc[date, :] = f(x_values)
    
    # Create a BytesIO object to hold the CSV data
    csv_buffer = BytesIO()

    # Write DataFrame to the buffer as a CSV
    interpolated_yield_curves.to_csv(csv_buffer)

    # Reset buffer position to start
    csv_buffer.seek(0)

    # Create a ZipFile object
    with zipfile.ZipFile('../data/interpolated_yield_curves.zip', 'w') as zipf:
        # Add the CSV file to the zip file
        zipf.writestr('interpolated_yield_curves.csv', csv_buffer.getvalue())


    print('\n\nYield curve data download is complete!\n')

   
if __name__ == "__main__":
    sys.exit(main())


